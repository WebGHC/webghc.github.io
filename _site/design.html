<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width,maximum-scale=2">
    <meta name="description" content="webghc.github.io : ">

    <link rel="stylesheet" type="text/css" media="screen" href="/assets/css/style.css?v=776888be9b3b0bf5e5090ab897d420d4ee16a19d">

    <title>webghc.github.io</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="http://github.com/WebGHC/webghc.github.io">View on GitHub</a>

          <h1 id="project_title">webghc.github.io</h1>
          <h2 id="project_tagline"></h2>

          
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h2 id="design">Design</h2>
<p>This project aims to solve the <em>JavaScript Problem</em> in a way that cuts JavaScript out of the build process altogether. In fact, this project is partially inspired by the HaskellWiki article “<a href="https://wiki.haskell.org/The_JavaScript_Problem">The JavaScript Problem</a>”.  The article outlines many of the current issues with developing in JavaScript, as well as current paths of recourse that exist in a functional paradigm. In particular, in the final section of the article mentions <a href="https://github.com/kripken/emscripten">Emscripten</a>.</p>

<blockquote>
  <p>“Emscripten — not Haskell→JS, but compiles LLVM/Clang output to JavaScript. Could possibly be used for GHC→LLVM→JS compiling, which I tried, and works, but would have to also compile the GHC runtime which is not straight-forward (to me) for it to actually run.”</p>
</blockquote>

<p>This helped inspire the initial design of a viable pathway from Haskell code to working <a href="http://webassembly.org/">WebAssembly</a> through <a href="http://llvm.org/">LLVM</a> using <a href="https://nixos.org/nix/">Nix</a>. The final product of this project will be a simple-to-use tool that consumes Haskell code and produces runnable WebAssembly.</p>

<p>LLVM is a sensible stepping stone for this project for several reasons. For one, LLVM is already the target of several widely used compilation tools. As such, many optimizations have been applied to the LLVM toolchain. Bringing LLVM into the project allows it to take advantage of all the optimizations. Furthermore, there already exist tools in the LLVM ecosystem for <a href="https://reviews.llvm.org/rL246814">compiling LLVM to WebAssembly</a>. Finally, GHC already has a working <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Backends/LLVM/Design">LLVM backend</a>. This solidifies LLVM as a path of least resistance for this project. Currently, LLVM code produced by the GHC LLVM backend cannot be directly translated into WebAssembly with the available tools due to some compatibility issues. Making an altered version of the LLVM backend that produces code that is compatible with LLVM-to-WebAssembly compilation available as a part of GHC will be a task that is accomplished within the context of this project.</p>

<p>Drawing together separately developed tools into a single cohesive product is often a fragile process that yields brittle results. Dependency management, and build processes need to be handled with care. The Nix language and ecosystem exist to handle these tasks with strength and reliability. Compiling GHC-produced LLVM to WebAssembly with the available LLVM tools is likely to be a sensitive process. Refining this process and capturing that logic via Nix will be done as a part of this project.</p>

<p>Producing sensible WebAssembly from Haskell code is not enough to fulfill the goals of this project. The produced WebAssembly code will be unable to run in the abscence of a proper runtime. Specifically, the <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts">GHC RTS</a> will need to be compiled to WebAssembly. The RTS exists as a combination of C and Cmm code within the GHC code base. The GHC LLVM backend already has the ability to take in Cmm code and produce LLVM, so the altered backend will serve double duty by aiding this process. A reliable C to LLVM compiler, Clang, already exists as part of the LLVM ecosystem. In addition, Emscripten furnishes implementations of several libraries, such as libc, that may be of use in this process. Leveraging these tools should make compiling the RTS to LLVM (and then WebAssembly) a far less daunting task.</p>

<p>A custom build process that builds GHC for the purpose of this project will need to be designed. This process can be encoded with Nix. In fact, <a href="https://github.com/Ericson2314">John Ericson</a> has already done significant work related to cross compilation with GHC using Nix. His work will aid in this cause, and is available via <a href="http://nixos.org/nixpkgs/">Nixpkgs</a>.</p>

<p>This project will expose a simple-to-use interface to end users. Encoding the logic necessary to use the results of this project properly should be possible via Nix. The necessary calls to Nix can then be written into simple bash files such that usage of this project requires no knowledge of its inner workings or the tools it uses. In this manner, the end users of this project should be able to compile Haskell code to runnable WebAssembly with only a simple command.</p>

      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        
        <p class="copyright">webghc.github.io maintained by <a href="http://github.com/WebGHC">WebGHC</a></p>
        
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    
  </body>
</html>
